#ifndef ABSYN_HEADER
#define ABSYN_HEADER

/* C++ Abstract Syntax Interface generated by the BNF Converter.*/

/********************   TypeDef Section    ********************/
typedef int Integer;
typedef char Char;
typedef double Double;
typedef char* String;
typedef char* Ident;
typedef char* Id;
typedef char* Ids;


/********************   Forward Declarations    ********************/

struct ListFunction_;
typedef struct ListFunction_ *ListFunction;
struct ListStm_;
typedef struct ListStm_ *ListStm;
struct ListArg_;
typedef struct ListArg_ *ListArg;
struct Program_;
typedef struct Program_ *Program;
struct Function_;
typedef struct Function_ *Function;
struct Arg_;
typedef struct Arg_ *Arg;
struct Stm_;
typedef struct Stm_ *Stm;
struct Type_;
typedef struct Type_ *Type;
struct Exp_;
typedef struct Exp_ *Exp;
struct QualId_;
typedef struct QualId_ *QualId;


/********************   Abstract Syntax Classes    ********************/

struct Program_
{
  enum { is_Prog } kind;
  union
  {
    struct { ListFunction listfunction_; } prog_;
  } u;
};

Program make_Prog(ListFunction p0);

struct Function_
{
  enum { is_DFunc } kind;
  union
  {
    struct { Id id_; ListArg listarg_; ListStm liststm_; Type type_; } dfunc_;
  } u;
};

Function make_DFunc(Type p0, Id p1, ListArg p2, ListStm p3);

struct Arg_
{
  enum { is_ADecl } kind;
  union
  {
    struct { Id id_; Type type_; } adecl_;
  } u;
};

Arg make_ADecl(Type p0, Id p1);

struct ListFunction_
{
  Function function_;
  ListFunction listfunction_;
};

ListFunction make_ListFunction(Function p1, ListFunction p2);
struct ListStm_
{
  Stm stm_;
  ListStm liststm_;
};

ListStm make_ListStm(Stm p1, ListStm p2);
struct ListArg_
{
  Arg arg_;
  ListArg listarg_;
};

ListArg make_ListArg(Arg p1, ListArg p2);
struct Stm_
{
  enum { is_SExp, is_SReturn } kind;
  union
  {
    struct { Exp exp_; } sexp_;
    struct { Exp exp_; } sreturn_;
  } u;
};

Stm make_SExp(Exp p0);
Stm make_SReturn(Exp p0);

struct Exp_
{
  enum { is_EInt, is_EStr, is_ELs } kind;
  union
  {
    struct { Integer integer_; } eint_;
    struct { Id id_; } estr_;
    struct { Exp exp_1, exp_2; } els_;
  } u;
};

Exp make_EInt(Integer p0);
Exp make_EStr(Id p0);
Exp make_ELs(Exp p0, Exp p1);

struct Type_
{
  enum { is_Tint } kind;
  union
  {
  } u;
};

Type make_Tint(void);

struct QualId_
{
  enum { is_Iden, is_Idens } kind;
  union
  {
    struct { Ident ident_; } iden_;
    struct { Ident ident_; QualId qualid_; } idens_;
  } u;
};

QualId make_Iden(Ident p0);
QualId make_Idens(QualId p0, Ident p1);



#endif
